//This folder contains a library for yabasic that allows yabasic to display 
//a variety of dialogs in text mode without making use of external commands.

//*Some* routines will also be made available in graphics mode, but keep 
//in mind that you only have one graphics window to play with. if you use 
//these, you will not have the graphics window for your own use.

//The library is written as a textmode application and must be run in a terminal. 
//It will not be useful in a headless script.

//The entire set of libraries focuses on sane defaults and getting basic 
//functionality into yabasic.

//Developed on elementary OS 0.4 "Loki" (i.e. Linux), but it should work on 
//any *NIX system that will run yabasic. I don't have a Windows machine to 
//test this on, so please let me know if anything works/doesn't work on that side.

//The library should exist either in the same folder as your program 
//(symlinks work) or in the standard yabasic library location on your system.

//To use the library, use the command 

//    import clasquinatorlib

//You should **not** use this library and one of the others in this set that 
//provides dialogs concurrently, because they replicate subroutine names. 
//Pick the right one for your program and stick with it!

//COMMON ROUTINES

#COM######### A ###########
#COM######### B ###########
#COM######### C ###########

export sub ClearDlg()
	//dummy routine for compatibility, since
	//it does not really make sense in clasquinator
end sub

#COM######### D ###########
#COM######### E ###########
#COM######### F ###########
#COM######### G ###########
#COM######### H ###########
#COM######### I ###########

export sub InputDlg$(text$, title$, ok$, cancel$)
	//Presents a one-line dialog into which the 
	//user can type a string answer.
end sub

#COM######### J ###########
#COM######### K ###########
#COM######### L ###########
#COM######### M ###########

export sub MenuDlg(text$, title$, ok$, cancel$, menustring$)
	//Create a menu of options for the user to choose from
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string, separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The result is returned as a numeric value, starting from 1
end sub

export sub MenuDlg$(text$, title$, ok$, cancel$, menustring$)
	//Create a menu of options for the user to choose from
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string,
	//separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The result is returned as a string value, starting from 1
end sub

export sub MessageDlg(text$, ok$)
	//display a simple message with an OK button 
	//The value *ok$* is the text of the accept button, normally OK.
	//This "button" is not mouse-aware
	//The first letter of ok$  becomes the trigger
	//if text$ is too long it will be truncated.
	//excessive quote marks (required in other libraries} will be removed
	//to maintain compatibility. Exessive spaces will be trimmed.
	//returns nothing
	local a$, original$, spaceleft, trigger$, ltrigger$, utrigger$
	trigger$ = left$(ok$,1): utrigger$ =upper$(trigger$): ltrigger$ = lower$(trigger$)
	if left$(text$,1) = "\"" or left$(text$,1) = "'" text$ = right$(text$, len(text$) - 1) 
	if right$(text$,1) = "\"" or right$(text$,1) = "'" text$ = left$(text$, len(text$) - 1) 
	text$ =trim$(text$)
	original$ = get_screen$ (1,3)
	fill_line_with_blanks(0): fill_line_with_blanks(1): fill_line_with_blanks(2)
	fill_line_with_symbols(1,0, "-")
	spaceleft = screenwidth - calculate_button_size(ok$) - 2
	print color(menu_colour$) at(1, 0) left$(text$, spaceleft);
	print color(menu_colour$) at (screenwidth - calculate_button_size(ok$) - 1, 0) "<";
	print color(trigger_colour$) at (screenwidth - calculate_button_size(ok$) , 0) trigger$;
	print color(menu_colour$) at (screenwidth - calculate_button_size(ok$) + 1, 0) right$(ok$, len(ok$) -1) + ">";
	a$ = inkey$
	//Since there is only one button 
	//and the routine returns nothing,
	//there is no point in trapping the actual keypress
	//but it is best to look consistent
	put_screen(1,original$)
end sub

#COM######### N ###########
#COM######### O ###########
#COM######### P ###########

export sub PasswordDlg$(text$, title$, ok$, cancel$)
	//Presents a one-line dialog into which the 
	//user can type a string answer with the text
	//replaced with asterisks
end sub

#COM######### Q ###########
#COM######### R ###########

export sub RadioDlg(text$, title$, ok$, cancel$, menustring$,selected$)
	//Create a menu of options for the user to choose from
	//Same as MenuDlg$(), except that you can indicate which item in
	//menustring$ is currently selected or active.
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string, 
	//separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The value selected$ is the currently selected item and must correspond to one of the items in 
	//menustring$ - case sensitive!
	//Just moving the cursor is not enough here - the value in the menu must be
	//explicitly selected with SPACE.
	//The result is returned as a numeric value, starting from 1
end sub

export sub RadioDlg$(text$, title$, ok$, cancel$, menustring$,selected$)
	//Create a menu of options for the user to choose from
	//Same as MenuDlg$(), except that you can indicate which item in
	//menustring$ is currently selected or active.
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string, 
	//separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The value selected$ is the currently selected item and must correspond to one of the items in 
	//menustring$ - case sensitive!
	//Just moving the cursor is not enough here - the value in the menu must be
	//explicitly selected with SPACE.
	//The result is returned as a string value, starting from 1
end sub

#COM######### S ###########
#COM######### T ###########

export sub TestForDialogUtility$()
	//dummy routine for compatibility, since
	//it does not really make sense in clasquinator
end sub 

export sub TextFileDlg(filename$, title$, exit$)
	//Displays a text file.
	//The value title$ is the title on top of the widget
	//The value exit$ is the title of the button. Normally OK
	//Text wrapping varies from one dialog-provider to the next.
	//It is better if you preformat your text file.
	//Returns nothing
end sub

#COM######### U ###########
#COM######### V ###########
#COM######### W ###########
#COM######### X ###########
#COM######### Y ###########

export sub YesNoDlg(text$,yes$, no$)
	//Displays a dialog with text (normally a question) and the options
	//to reply yes or no.
	//returns 1 for yes and 0 for no.
end sub

#COM######### Z ###########


//CLASQUINATOR-SPECIFIC ROUTINES

export sub SubmenuDlg(text$, title$, ok$, cancel$, menustring$)
	//Create a secondary menu of options for the user to choose from
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string, separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The result is returned as a numeric value, starting from 1
end sub

export sub SubmenuDlg$(text$, title$, ok$, cancel$, menustring$)
	//Create a secondary menu of options for the user to choose from
	//The value *title$* is the title on top of the widget
	//The value *ok$* is the text of the accept button, normally OK.
	//The value *cancel$* is the text of the reject button, normally Cancel.
	//The value menustring$ is the list of menu options as a single string,
	//separated by hash signs (#). Spaces are allowed.
	//If the number of options exceed the available space in the widget, the list will be scrollable.
	//The result is returned as a string value, starting from 1
end sub

//SUPPORTIVE SUBROUTINES

export sub getcmd$()
	//This is really just for me, to stop me from
	//getting confused while I am editing four
	//libraries simultaneously.
	//However, you could use it to test which utility
	//(or library, in the case of clasquinator)
	//is currently running and if it is safe to use routines
	//not in the common list.
	//e.g if getcmd$() = "clasquinator" SubmenuDlg(options ....)
	return "clasquinator"
end sub

export sub clasquinator_initialise()
	//sets up the GLOBAL numeric variables screenwidth and screenheight
	//Sorry about that, but these really will be used all over and passing them locally
	//just is not feasible.
	//Must be run before you can run any other commands
	//and called again before every dialog-creating command to see if your 
	//user resized the terminal window.
	//You can just put the following line in all your programs
	//    if getcmd$() = "clasquinator" clasquinator_initialise()
	//that way it won't affect any other library and yoiu can still change libraries
	//with a minimum of fuss.
	if screenwidth <> peek("screenwidth") or screenheight <> peek("screenheight") then
		screenwidth=peek("screenwidth")
		screenheight=peek("screenheight")
	endif
	if menu_colour$ = "" menu_colour$ = "cyan"
	if trigger_colour$ = "" trigger_colour$ = "red"
end sub

sub get_screen$(pos,lines)
	//The value *pos* must be either 1 for top or 0 for bottom.
	//The value *lines* indicates the number of lines you want to grab 
	local content$
	clasquinator_initialise()
	if pos > 1 pos = 1: if pos < 0 pos = 0
	if pos =1 content$ = getscreen$(0,0, screenwidth - 1,lines-1)
	if pos = 0 content$ = getscreen$(0, screenheight - lines - 1, screenwidth-1, screenheight - 1)
	return content$
end sub

sub put_screen(pos,content$,lines)
	//The value *pos* must be either 1 for top or 0 for bottom.
	//if pos equals 1 the lines value is not required
	//if pos equals 0 the lines value must be supplied
	//The value content$ is the string you grabbed earlier with the get_screen$() routine
	clasquinator_initialise()
	if pos > 1 pos = 1: if pos < 0 pos = 0
	if pos = 1 putscreen content$, 0, 0
	if pos = 0 putscreen content$, 0, screenheight - lines - 1
end sub

sub fill_line_with_symbols(lin, mode, symbol$)
	//fill a line with blanks (i.e. clear it) prior to placing information there
	//mode = 0 means using the normal print (default)
	//mode = 1 means using reverse print
	//symbol$ can be any character you wish, like -, = or #
	// If supplied, it will be used to draw the line instead of spaces.
	if symbol$ = "" symbol$ = " "
	if len(symbol$) > 1 symbol$ = left$(symbol$,1)
	print at (0, lin) " ";
	for f = 1 to screenwidth -2
		if mode = 1 then
			print colour ("black", menu_colour$) at (f, lin) symbol$;
		else
			print colour (menu_colour$, "black") at (f, lin) symbol$;
		endif
	next f
end sub

sub fill_line_with_blanks(lin)
	//fill a line with completely black spaces
	//for some starnge reason this does not work with a for ... next loop
	local a$
	a$ = str$(screenwidth) + ",1:"
	for f = 1 to screenwidth
		a$ = a$ + " :Bla:Bla,"
	next f
	a$ = a$ + ", blb"
	putscreen a$, 0, lin
end sub

sub calculate_button_size(button$)
	return len(button$) + 3
end sub

	