export sub TestForUtility$(utility$)
	//internal routine to test if the called utility actually exists
	//an empty string returned means it does.
	local which$
	which$ = system$("which " + utility$)
	if which$ = "" return "The required program " + utility$ + " does not exist on this system"
end sub

export sub IsItATextFile(filename$)
	//Tests whether a given file is a text file or not
	//anytjhing that does not have the string "text" in the results of the
	//file command is assumed to be a binary file.
	//This should work fine on Linux but may be problematic on BSD systerms
	//where this command may reject shell scripts
	//if you need something more powerful I suggest you install enca.
	if instr(system$ ("file " + filename$), "text") then
		return 1
	else
		return 0
	endif
end sub

export sub OpenInNano$(filename$)
	//opens a given text file in the nano text editor.
	//must be run in a program that is already in a terminal
	//For best results your filename should be enclosed in single
	//quotation marks so that it will not get confused by spaces. This
	//routine will not check for that.
	local UTest$
	UTest$ = TestForUtility$("nano")
	if UTest$ <> "" then
		return UTest$
	else
		system("nano " + filename$)
	endif
end sub

export sub StripLFoffSysCmd$(tempval$)
	//remove LF from the results of a system call
	//if the results of a System() or System$() command end on a LF (most do),
	//strip the LF off and return the resulting string
	if instr(tempval$, "\n", len(tempval$)) <> 0 then //if the string ends with a LF
		tempval$ = left$(tempval$, len(tempval$)-1) //strip off trailing newline
        endif
        return tempval$
end sub

export sub ArraySort(z())
	//sorts a ONE-dimensional numeric array
	//Usage: ArraySort(a())
	//do not try a() =  ArraySort(a()), it won't work
	//your array should be global - I have had inconsistent results 
	//with local arrays.
        local tempfile1$, tempfile2$,upperlimit, handle, item$
        tempfile1$ = TempDir$() + "/" + str$(RandInt())
        tempfile2$ = TempDir$() + "/"  + str$(RandInt())
        upperlimit =arraysize(z(),1)
        handle = open(tempfile1$,"w")
        for f = 1 to upperlimit
                print #handle str$(z(f))
        next f
        close handle
        system("sort -bn " + tempfile1$ + " > " + tempfile2$)
        handle = open(tempfile2$,"r")
        for f = 1 to upperlimit
                line input #handle item$
                z(f) = val(item$)
        next f
        close handle
	system("rm " + tempfile1$)
        system("rm " + tempfile2$)
end sub

export sub ArraySort$(z$())
	//sorts a ONE-dimensional string array (case-independent)
	//Usage: ArraySort$(a$())
	//do not try a$() =  ArraySort$(a$()), it won't work
	//your array should be global - I have had inconsistent results 
	//with local arrays.
        local tempfile1$, tempfile2$,upperlimit, handle, item$
        tempfile1$ = TempDir$() + "/" + str$(RandInt())
        tempfile2$ = TempDir$() + "/" + str$(RandInt())
        upperlimit =arraysize(z$(),1)
        handle = open(tempfile1$,"w")
        for f = 1 to upperlimit
                print #handle z$(f)
        next f
        close handle
        system("sort -bf " + tempfile1$ + " > " + tempfile2$)
        handle = open(tempfile2$,"r")
        for f = 1 to upperlimit
                line input #handle item$
                z$(f) = item$
        next f
        close handle
        system("rm " + tempfile1$)
        system("rm " + tempfile2$)
end sub

export sub FileExists(fullpathname$)
	//test if a file exists
	//returns 1 - file exists
	//returns 0 - file does not exist
        local handle
        handle = open(fullpathname$,"r")
        if handle then
                close handle
                return 1
        else
                return 0
        endif
end sub

export sub FileorDir(pathname$)
	//determines if a passed filename is a file or a directory
	//returns 1 if the passed variable is a directory
	//returns 0 if it is a file
        local isadir$
        isadir$ = system$("if test -d " + pathname$ + ";then echo 1; else echo 0;fi")
	return val(isadir$)
end sub

export sub FileorLink(pathname$)
	//determines if a passed filename is a file/directory or a symlink
	//returns 1 if the passed variable is a link
	//returns 0 if it is a file/directory
        local isalink$
        isalink$ = system$("if test -L " + pathname$ + ";then echo 1; else echo 0;fi")
	return val(isalink$)
end sub

export sub IsFileZeroByte(pathname$)
	//determines if a passed filename is a zero-byte file
	//returns 1 if the passed variable is larger than zero bytes
	//returns 0 if it is zero bytes in size
	//(note that this reverses the output of the test -s command)
	//caution: will also retun 0 if file does not exist
	//test for that with FileExists first
	//caution: will also return 1 if file is actually a directory
	//test for that with FileorDir first
	//caution: If the file given is a symlink, this routine will report on the real, linked file
        local isazero$
        isazero$ = system$("if test -s " + pathname$ + ";then echo 0; else echo 1;fi")
	return val(isazero$)
end sub

export sub EncloseString$(thestring$,type)
	//Encloses a string in either single or double quotes, if it isn't already
	//mostly for use with long filenames that may include spaces.
	//type is either 0 (single quote) or 1 (double quote)
	local type$, type2$
	if type = 0 then
		type$ = chr$(39): type2$ = chr$(34)
	else
		type$ = chr$(34): type2$ = chr$(39)
	endif
	if left$(thestring$,1) <> type$ and left$(thestring$,1) <> type2$ thestring$ = type$ + thestring$
	if right$(thestring$,1) <> type$ and right$(thestring$,1) <> type2$ thestring$ = thestring$ + type$
	return thestring$
end sub	

export sub WhereAmI$()
	local path$
        if (peek("isbound")) then
                path$=peek$("directory")
        else
                path$=system$("pwd")
        endif
         path$ = StripLFoffSysCmd$(path$)
         // I prefer not to add the trailing slash at this point
        return path$
end sub

sub TempDir$()
//returns the location of Linux's TMPDIR directory
//technically not necessary, but a lot of my routines
//ported from Haiku expect to see this.
//note: no traling "/", you will have to add that.
//edit the line below if necessary on a different Unix-like OS
        return "/tmp"
end sub

sub RandInt()
//returns a random integer between 0 and 32767
//used here to generate random filenames to place in TMPDIR
        local a
        a = int(ran(32768))
        return a
end sub





